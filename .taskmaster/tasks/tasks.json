{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "i18n 구조 리팩터링 및 YAML 로더 도입",
        "description": "기존 LanguageContext에 하드코딩된 번역 키를 `src/i18n/{lang}/{namespace}.yaml` 파일로 분리하고, 이를 동적으로 로드하는 로더와 `t(path, vars)` 유틸리티 함수를 구현합니다. 이는 향후 유지보수성, 협업 효율성, 가독성을 크게 개선합니다.",
        "status": "in-progress",
        "dependencies": [],
        "priority": "high",
        "details": "1. `yaml`, `vite-plugin-yaml` 의존성을 프로젝트에 추가합니다. (`pnpm add yaml vite-plugin-yaml -D`).\n2. `vite.config.ts`에 YAML 플러그인을 설정합니다.\n3. `src/i18n/{ko,en,ja}/{common,landing}.yaml` 파일 구조를 생성하고, 기존 랜딩페이지의 Hero/CTA 텍스트를 샘플로 이전합니다.\n4. `LanguageContext`를 리팩터링하여, 선택된 언어와 네임스페이스에 따라 YAML 파일을 동적으로 import하는 `loadMessages(lang, namespaces)` 비동기 함수를 구현합니다.\n5. `t(path, vars)` 유틸리티 함수를 구현합니다. 이 함수는 'namespace.key.subkey'와 같은 경로를 파싱하고, 로드된 메시지 객체에서 값을 찾습니다. 변수 치환 기능(예: `t('greeting', { name: 'World' })`)도 지원해야 합니다. 키가 없을 경우 경고를 출력하고 경로 자체를 반환합니다.",
        "testStrategy": "1. 언어(ko, en, ja)를 변경했을 때 해당 언어의 YAML 파일이 네트워크 탭에서 정상적으로 로드되는지 확인합니다.\n2. `t()` 함수가 올바른 번역 문자열을 반환하는지 컴포넌트 단위 테스트를 작성합니다.\n3. 존재하지 않는 키를 `t()` 함수에 전달했을 때 콘솔에 경고가 출력되고, 기본값 또는 키 경로가 렌더링되는지 확인합니다.\n4. 변수 치환 기능이 정상적으로 동작하는지 검증합니다.",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "리포트 및 뉴스레터 샘플 데이터 모델 정의 및 JSON 파일 생성",
        "description": "B2B 가치를 증명할 데일리 리포트, 마일스톤 리포트, CM 리아 뉴스레터의 정적 샘플 데이터를 위한 TypeScript 타입과 JSON 파일을 생성합니다. 이는 페이지 구현의 기반 데이터가 됩니다.",
        "status": "pending",
        "dependencies": [],
        "priority": "high",
        "details": "1. `src/types/reports.ts`와 같은 파일을 생성하여 `DailyReport`, `MilestoneReport`, `Newsletter` 데이터 구조에 대한 TypeScript 인터페이스를 정의합니다.\n2. `DailyReport`는 `kpi`, `delta`, `keywords`, `issues`, `quotes` 필드를 포함해야 합니다.\n3. `MilestoneReport`는 `executiveSummary`, `featureFeedback`, `comparison`, `keywords` 필드를 포함해야 합니다.\n4. `src/data/reports/daily/`, `src/data/reports/milestone/`, `src/data/newsletter/` 디렉토리를 생성합니다.\n5. 각 디렉토리 내에 정의된 인터페이스에 맞는 샘플 `*.json` 파일을 2~3개씩 생성합니다. 뉴스레터 JSON에는 `gameId` 필드를 반드시 포함시켜야 합니다.",
        "testStrategy": "1. 생성된 모든 `.json` 파일이 유효한 JSON 형식인지 린터 또는 온라인 검사기로 확인합니다.\n2. TypeScript 프로젝트에서 이 JSON 파일들을 import 했을 때, 정의된 인터페이스와 타입이 일치하여 타입 에러가 발생하지 않는지 확인합니다.\n3. 각 JSON 파일의 필수 필드들이 누락되지 않았는지 검토합니다.",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "데일리/마일스톤 리포트 상세 페이지 라우트 및 템플릿 구현",
        "description": "신규 B2B 가치 증빙을 위해 데일리 리포트와 마일스톤 리포트 상세 페이지를 생성합니다. React Router를 사용하여 동적 라우트를 추가하고, 각 페이지의 기본 템플릿을 구성합니다.",
        "status": "pending",
        "dependencies": [
          2
        ],
        "priority": "high",
        "details": "1. `src/pages/reports/` 디렉토리에 `DailyReportPage.tsx`와 `MilestoneReportPage.tsx` 컴포넌트를 생성합니다.\n2. React Router 설정 파일(예: `src/App.tsx`)에 `/:lang/reports/daily/:game/:date`와 `/:lang/reports/milestone/:game/:milestoneId` 동적 라우트를 추가합니다.\n3. 각 페이지 컴포넌트 내에서 `useParams` 훅을 사용하여 URL 파라미터(game, date 등)를 추출합니다.\n4. 추출된 파라미터를 기반으로 Task 2에서 생성한 정적 JSON 데이터를 동적으로 import하여 로드하는 로직을 구현합니다. (예: `import(`/src/data/reports/daily/${game}-${date}.json`)`).\n5. 로드된 데이터를 사용하여 페이지의 제목, 요약 등 기본적인 정보를 렌더링하는 초기 템플릿을 구성합니다.",
        "testStrategy": "1. 브라우저에서 `/en/reports/daily/sample-game/2024-01-01`과 같은 URL로 직접 접속했을 때 해당 페이지가 올바르게 렌더링되는지 확인합니다.\n2. URL 파라미터가 변경됨에 따라 다른 JSON 데이터가 로드되고 콘텐츠가 변경되는지 검증합니다.\n3. 존재하지 않는 데이터에 대한 URL로 접근 시, 404 페이지로 안내하거나 홈페이지로 리디렉션되는 등 예외 처리가 적절히 이루어지는지 확인합니다.",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "랜딩 페이지 IA 재구성 및 B2B 카피/CTA 톤 적용",
        "description": "랜딩 페이지의 정보 구조(IA)를 B2B 가치 중심(Hero → 프리뷰 → 기능 소개)으로 재구성하고, 전체 카피와 CTA를 B2C 톤에서 B2B 톤('문의하기' 중심)으로 변경합니다.",
        "status": "pending",
        "dependencies": [
          1
        ],
        "priority": "high",
        "details": "1. 랜딩 페이지 메인 컴포넌트(`pages/Index.tsx` 등)의 JSX 구조를 수정하여 섹션 순서를 PRD에 명시된 'Hero + Daily/Milestone 프리뷰 + 인사이트 어시스턴트&뉴스레터 + ...' 순서로 재배치합니다.\n2. 각 주요 섹션의 최상위 `<div>`에 `id=\"daily-preview\"`와 같은 앵커 ID를 부여합니다.\n3. 프로젝트 전역에서 'Discord 합류하기'와 같은 B2C 문구를 'Discord로 문의하기' 또는 '데모 요청하기' 등의 B2B 문구로 변경합니다.\n4. 모든 텍스트를 하드코딩된 문자열에서 Task 1에서 구현한 `t()` 함수를 사용하도록 교체합니다. (예: `<h2>Join our Discord</h2>` → `<h2>{t('landing.hero.title')}</h2>`).\n5. `src/i18n/{lang}/landing.yaml` 파일에 새로운 B2B 톤의 카피들을 모두 정의합니다.",
        "testStrategy": "1. 랜딩 페이지의 섹션 순서가 디자인 시안 및 PRD와 일치하는지 시각적으로 확인합니다.\n2. 헤더 네비게이션의 앵커 링크 클릭 시 해당 섹션으로 부드럽게 스크롤되는지 검증합니다.\n3. 페이지 내 모든 CTA 버튼과 주요 카피가 B2B 톤으로 변경되었는지 확인합니다.\n4. 언어 변경 시 모든 텍스트가 해당 언어로 즉시 변경되는지 확인하고, 누락된 번역 키가 없는지 검토합니다.",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "인사이트 어시스턴트(챗봇 시뮬레이터) 및 뉴스레터 통합 섹션 개발",
        "description": "랜딩 페이지 내에 사용자의 이해를 돕기 위한 '인사이트 어시스턴트 & CM 리아' 통합 섹션을 개발합니다. 여기에는 인터랙티브한 챗봇 시뮬레이터와 뉴스레터 샘플 카드가 포함됩니다.",
        "status": "pending",
        "dependencies": [
          2,
          4
        ],
        "priority": "medium",
        "details": "1. `src/components/` 내에 `ChatSimulator.tsx`와 `NewsletterSection.tsx` 컴포넌트를 생성합니다.\n2. `ChatSimulator.tsx`는 'typing→thinking→analyzing→result' 단계를 표현하는 상태(state)를 가집니다. `useEffect`와 `setTimeout`을 조합하여 각 단계가 순차적으로 애니메이션과 함께 표시되도록 구현합니다. 접근성을 위해 상태 변화를 알리는 영역에 `aria-live=\"polite\"` 속성을 추가합니다.\n3. `NewsletterSection.tsx`는 Task 2의 `newsletter.json` 데이터를 props로 받아 카드 리스트를 렌더링합니다. 모바일에서는 캐로셀로 표시될 것을 대비하여 아이템 단위로 컴포넌트를 분리합니다.\n4. 이 두 컴포넌트를 랜딩 페이지의 지정된 위치에 배치하고 스타일링합니다.",
        "testStrategy": "1. 챗봇 시뮬레이션이 시작부터 결과 출력까지 끊김 없이 자연스럽게 동작하는지 확인합니다.\n2. Chrome DevTools의 Performance 탭을 사용하여 시뮬레이션 중 프레임 드랍이 발생하는지(60fps 유지) 확인합니다.\n3. 스크린 리더(VoiceOver, NVDA)를 켜고 시뮬레이션이 진행될 때, `aria-live` 영역의 내용이 음성으로 출력되는지 확인합니다.\n4. 뉴스레터 카드 데이터가 JSON 파일의 내용과 일치하게 렌더링되는지 확인합니다.",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "리포트 상세 페이지 SEO 최적화 (JSON-LD, Meta Tags)",
        "description": "검색 엔진 최적화를 위해 리포트 상세 페이지에만 인덱싱을 적용하고, 구조화된 데이터(JSON-LD) 및 다국어 관련 메타 태그(hreflang, canonical)를 동적으로 주입합니다.",
        "status": "pending",
        "dependencies": [
          3
        ],
        "priority": "medium",
        "details": "1. `react-helmet-async` 라이브러리를 설치하고 애플리케이션 최상단에 `HelmetProvider`를 설정합니다.\n2. `DailyReportPage.tsx` 및 `MilestoneReportPage.tsx` 내에서 `Helmet` 컴포넌트를 사용합니다.\n3. 페이지 데이터가 로드되면 `title`, `meta[name=description]`, `link[rel=canonical]` 태그를 동적으로 생성합니다. Canonical URL은 현재 페이지의 정식 주소를 가리키도록 합니다.\n4. `hreflang` 링크 태그를 생성하여 동일한 콘텐츠의 다른 언어 버전 페이지 주소를 명시합니다.\n5. 페이지 콘텐츠를 기반으로 `Article`과 `BreadcrumbList` 타입의 JSON-LD 스크립트 객체를 생성하고, `<script type=\"application/ld+json\">` 태그 안에 `JSON.stringify()`하여 삽입합니다.\n6. 랜딩 페이지에는 `<meta name=\"robots\" content=\"noindex\" />` 태그를 추가하여 검색 결과에서 제외시킵니다.",
        "testStrategy": "1. 리포트 상세 페이지 접속 후, 브라우저 개발자 도구의 Elements 탭에서 `<head>` 태그 내에 `title`, `description`, `canonical`, `hreflang` 태그가 올바르게 삽입되었는지 확인합니다.\n2. 페이지 소스 보기에서 JSON-LD 스크립트가 정상적으로 포함되어 있는지 확인합니다.\n3. Google의 'Rich Results Test' 도구를 사용하여 페이지 URL을 입력하고, `Article`과 `BreadcrumbList` 구조화 데이터가 유효한지 검증합니다.",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "리포트 상세 페이지용 데이터 시각화 컴포넌트 개발",
        "description": "리포트 상세 페이지에서 KPI, 키워드, 이슈 등의 핵심 데이터를 효과적으로 보여주기 위한 재사용 가능한 UI 컴포넌트들(`ReportKPI`, `DeltaBar`, `KeywordTable` 등)을 개발합니다.",
        "status": "pending",
        "dependencies": [
          3
        ],
        "priority": "medium",
        "details": "1. `src/components/reports/` 디렉토리를 만들고 그 안에 `ReportKPI.tsx`, `DeltaBar.tsx`, `KeywordTable.tsx`, `IssueTable.tsx`, `QuoteList.tsx` 컴포넌트 파일을 생성합니다.\n2. shadcn/ui의 `Card`, `Table`, `Progress` 등 기본 컴포넌트를 조합하여 각 시각화 컴포넌트를 구현합니다.\n3. `ReportKPI.tsx`는 숫자와 라벨, 변화율(delta)을 표시합니다.\n4. `DeltaBar.tsx`는 값의 긍정/부정 여부에 따라 색상이 다른 바(bar)를 렌더링합니다.\n5. `KeywordTable.tsx`은 shadcn/ui의 `Table`을 사용하여 키워드, 빈도수, 감성 점수 등을 표시합니다.\n6. 각 컴포넌트는 props로 데이터를 받아 렌더링하며, 데이터가 없는 경우를 대비한 UI 처리(예: '데이터 없음' 메시지)를 포함합니다.\n7. 이 컴포넌트들을 `DailyReportPage.tsx`와 `MilestoneReportPage.tsx`에 통합하여 실제 데이터를 렌더링합니다.",
        "testStrategy": "1. Storybook 또는 유사한 환경에서 각 컴포넌트를 독립적으로 테스트합니다. 다양한 데이터(정상, 비정상, 빈 값)를 props로 전달하여 UI가 깨지지 않는지 확인합니다.\n2. `DailyReportPage`와 `MilestoneReportPage`에서 컴포넌트들이 JSON 데이터와 연동되어 올바르게 표시되는지 통합 테스트를 진행합니다.\n3. 모바일 화면 크기에서도 테이블과 차트가 깨지지 않고 반응형으로 잘 표시되는지 확인합니다.",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "주요 랜딩 섹션에 모바일 캐로셀 기능 확대 적용",
        "description": "모바일 환경에서 정보 탐색의 편의성을 높이기 위해 'Problem', 'Solution', 'Partner', 'Benefits' 섹션의 콘텐츠 목록을 스와이프 가능한 캐로셀 형태로 변경합니다.",
        "status": "pending",
        "dependencies": [
          4
        ],
        "priority": "low",
        "details": "1. `embla-carousel-react` 및 관련 플러그인을 설치합니다.\n2. 화면 너비를 감지하는 `useMediaQuery` 커스텀 훅을 만듭니다. (예: `const isMobile = useMediaQuery('(max-width: 768px)');`).\n3. 재사용 가능한 `MobileCarousel.tsx` 래퍼 컴포넌트를 만듭니다. 이 컴포넌트는 `isMobile`이 true일 때만 Embla Carousel 로직을 활성화하고, false일 때는 children을 그대로 렌더링합니다.\n4. 'Problem', 'Solution', 'Partner', 'Benefits' 섹션의 아이템 리스트를 `MobileCarousel.tsx` 컴포넌트로 감싸도록 마크업을 수정합니다.\n5. 캐로셀의 스타일(예: 아이템 간 간격, 네비게이션 버튼)을 Tailwind CSS로 지정합니다.",
        "testStrategy": "1. 브라우저 개발자 도구에서 모바일 뷰(화면 너비 768px 이하)로 전환했을 때, 해당 섹션들이 스와이프 가능한 캐로셀로 변경되는지 확인합니다.\n2. 터치 또는 마우스 드래그로 캐로셀이 부드럽게 동작하는지 테스트합니다.\n3. 데스크탑 뷰로 다시 전환했을 때, 캐로셀이 비활성화되고 일반적인 그리드 또는 플렉스 레이아웃으로 정상 복귀하는지 확인합니다.",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "SSG/프리렌더링 설정 및 빌드 최적화",
        "description": "초기 로딩 속도(FMP)와 SEO 효율성을 극대화하기 위해 Vite 프로젝트에 정적 사이트 생성(SSG) 또는 프리렌더링 설정을 적용합니다. 이를 통해 빌드 시점에 각 페이지의 HTML 파일을 미리 생성합니다.",
        "status": "pending",
        "dependencies": [
          6,
          7
        ],
        "priority": "low",
        "details": "1. `vite-ssg` 또는 `vite-plugin-ssr`과 같은 Vite 기반 SSG 라이브러리를 검토하고 프로젝트에 적용합니다.\n2. SSG 설정 파일에서 동적 라우트들을 사전 생성할 경로 목록을 지정합니다. `fs` 모듈을 사용하여 `src/data/reports` 디렉토리의 JSON 파일 목록을 읽어와 동적 경로(`/:lang/reports/daily/...`)를 자동으로 생성하는 스크립트를 작성합니다.\n3. 빌드 스크립트(`package.json`의 `build` 명령어)를 SSG 빌드를 실행하도록 수정합니다.\n4. `vite-plugin-sitemap`과 같은 플러그인을 사용하여 빌드 시 `sitemap.xml`과 `robots.txt` 파일이 자동으로 생성되도록 구성합니다. `robots.txt`에는 사이트맵 경로를 명시하고, 랜딩 페이지는 disallow 처리할 수 있습니다.",
        "testStrategy": "1. `pnpm build` 실행 후, `dist` 폴더 안에 랜딩 페이지와 각 리포트 상세 페이지에 해당하는 `index.html` 파일들이 생성되었는지 확인합니다.\n2. `dist` 폴더를 로컬 서버로 실행한 뒤, 페이지 소스 보기(View Page Source)를 통해 React가 실행되기 전의 초기 HTML 콘텐츠가 미리 렌더링되어 있는지 확인합니다.\n3. Lighthouse 점수를 측정하여 빌드 전과 비교했을 때 Performance 및 SEO 점수가 개선되었는지 확인합니다.",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "최종 QA 및 마이그레이션 체크리스트 검증",
        "description": "리브랜딩 MVP의 모든 기능이 PRD의 요구사항과 수용 기준에 맞게 동작하는지 최종적으로 검증합니다. 여기에는 기능, 성능, 접근성, SEO 등 전반적인 품질 점검이 포함됩니다.",
        "status": "pending",
        "dependencies": [
          1,
          3,
          4,
          5,
          6,
          7,
          8,
          9
        ],
        "priority": "high",
        "details": "1. PRD의 'QA 체크', 'Done 기준', '수용 기준' 항목을 기반으로 테스트 체크리스트를 작성합니다.\n2. 핵심 플로우 테스트: 랜딩 페이지 진입 → 프리뷰 확인 → 상세 리포트 이동 → CTA 클릭.\n3. i18n 테스트: 모든 언어에서 텍스트 누락이나 깨짐이 없는지 확인.\n4. 접근성 테스트: 키보드만으로 모든 인터랙티브 요소에 접근하고 조작할 수 있는지 확인. ARIA 속성이 올바르게 사용되었는지 검증.\n5. 성능 테스트: Lighthouse로 FMP, LCP, TBT 등 주요 지표가 목표치(FMP≤5s)를 만족하는지 확인.\n6. SEO 검증: 외부 SEO 도구를 사용하여 메타 태그, JSON-LD, `robots.txt` 설정이 올바른지 최종 확인.\n7. 크로스 브라우저 테스트: Chrome, Safari, Firefox 최신 버전 및 모바일 환경에서 레이아웃 깨짐이나 기능 오작동이 없는지 확인.",
        "testStrategy": "실제 배포 환경과 동일한 스테이징 환경에서 E2E(End-to-End) 테스트를 수행합니다. 체크리스트 기반의 수동 테스트와 더불어, 가능하다면 Playwright나 Cypress를 이용한 자동화된 E2E 테스트 스크립트를 작성하여 주요 플로우를 검증합니다. 비기능적 요구사항(성능, 접근성)은 Lighthouse, WebPageTest, Axe와 같은 전문 도구를 사용하여 정량적으로 평가하고 리포트를 생성합니다.",
        "subtasks": [
          {
            "id": 1,
            "title": "핵심 기능 플로우 E2E 테스트",
            "description": "사용자의 핵심 여정(랜딩 페이지 진입 → 프리뷰 확인 → 상세 리포트 이동 → CTA 클릭)이 PRD에 정의된 대로 끊김 없이 동작하는지 End-to-End 테스트를 수행합니다.",
            "dependencies": [],
            "details": "PRD의 'QA 체크' 및 '수용 기준'을 바탕으로 테스트 케이스를 작성합니다. Playwright 또는 Cypress를 사용하여 핵심 플로우에 대한 자동화된 E2E 테스트 스크립트를 실행하고, 수동 테스트를 병행하여 엣지 케이스를 점검합니다.",
            "status": "pending",
            "testStrategy": "테스트 실행 후 모든 테스트 케이스가 통과했는지 확인하고, 실패 시 버그 리포트를 생성합니다. 테스트 결과를 QA 시트에 기록하여 문서화합니다."
          },
          {
            "id": 2,
            "title": "다국어(i18n) 전체 검증",
            "description": "지원하는 모든 언어(한국어, 영어, 일본어 등) 환경에서 텍스트 누락, 깨짐, 레이아웃 이탈 현상이 없는지 전반적으로 검증합니다.",
            "dependencies": [],
            "details": "각 언어 설정으로 변경하며 모든 페이지와 컴포넌트를 순회합니다. 특히 동적으로 생성되는 텍스트(리포트 데이터, 날짜 형식 등)가 각 언어권에 맞게 올바르게 표시되는지 집중적으로 확인합니다.",
            "status": "pending",
            "testStrategy": "각 언어별 스크린샷을 촬영하여 시각적 회귀 테스트를 수행하고, 번역 검수 담당자에게 전달하여 내용의 정확성을 확인받습니다. 발견된 모든 이슈는 i18n 관련 태그를 붙여 추적합니다."
          },
          {
            "id": 3,
            "title": "성능(Lighthouse) 및 로딩 속도 측정",
            "description": "Lighthouse 도구를 사용하여 주요 성능 지표(FMP, LCP, TBT 등)를 측정하고, 설정된 목표치(예: FMP≤5s)를 만족하는지 확인합니다.",
            "dependencies": [],
            "details": "Chrome 개발자 도구의 Lighthouse 탭 또는 Lighthouse CI를 사용하여 성능 리포트를 생성합니다. 이미지 최적화, 번들 크기, 렌더링 차단 리소스 등을 분석하여 성능 저하의 원인을 파악합니다.",
            "status": "pending",
            "testStrategy": "여러 차례 측정을 통해 평균 점수를 기록하고, 이전 빌드 결과와 비교하여 성능이 저하되지 않았는지 확인합니다. 최종 성능 리포트를 생성하여 팀에 공유합니다."
          },
          {
            "id": 4,
            "title": "웹 접근성(키보드, 스크린리더) 검증",
            "description": "키보드만으로 모든 인터랙티브 요소에 접근하고 조작할 수 있는지 확인하고, 스크린리더 사용 시 콘텐츠가 논리적인 순서로 전달되는지 검증합니다.",
            "dependencies": [],
            "details": "Tab, Shift+Tab, Enter, Space 키를 사용하여 페이지 내 모든 기능을 테스트합니다. Axe와 같은 자동화된 접근성 검사 도구를 사용하여 ARIA 속성의 올바른 사용, 명암비, 대체 텍스트 제공 여부 등을 점검합니다.",
            "status": "pending",
            "testStrategy": "WCAG 2.1 AA 레벨을 기준으로 체크리스트를 작성하고, 각 항목의 준수 여부를 기록합니다. 스크린리더(VoiceOver, NVDA 등)를 직접 사용하여 사용자 경험을 테스트하고 피드백을 문서화합니다."
          },
          {
            "id": 5,
            "title": "SEO 설정 최종 검증",
            "description": "검색 엔진 최적화(SEO) 관련 설정들(메타 태그, JSON-LD, robots.txt 등)이 올바르게 적용되었는지 최종적으로 확인하여 검색 결과 노출에 문제가 없도록 합니다.",
            "dependencies": [],
            "details": "외부 SEO 검증 도구 및 브라우저 개발자 도구를 사용하여 메타 태그, Open Graph 태그, JSON-LD 구조화 데이터, `robots.txt`, `sitemap.xml` 파일의 유효성과 정확성을 검증합니다.",
            "status": "pending",
            "testStrategy": "각 페이지별로 SEO 요소가 PRD 요구사항에 맞게 동적으로 생성되는지 확인합니다. Google Search Console의 URL 검사 도구를 사용하여 페이지가 정상적으로 수집되고 색인될 수 있는지 미리 테스트합니다."
          },
          {
            "id": 6,
            "title": "크로스 브라우저 호환성 테스트",
            "description": "주요 웹 브라우저(Chrome, Safari, Firefox)의 최신 버전과 모바일 환경(iOS, Android)에서 레이아웃 깨짐이나 기능 오작동이 없는지 확인합니다.",
            "dependencies": [],
            "details": "실제 디바이스 및 BrowserStack과 같은 테스트 플랫폼을 활용하여 다양한 브라우저/OS/해상도 조합에서 테스트를 수행합니다. CSS Flexbox/Grid, JavaScript API 등의 브라우저별 호환성 이슈를 중점적으로 점검합니다.",
            "status": "pending",
            "testStrategy": "브라우저별 테스트 결과를 체크리스트에 기록하고, 특정 환경에서만 발생하는 버그는 해당 환경 정보(브라우저 버전, OS, 해상도)와 함께 상세히 리포트합니다."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-10-31T02:47:03.677Z",
      "updated": "2025-10-31T03:02:13.859Z",
      "description": "Tasks for master context"
    }
  }
}